##### intern: function from the before named file 'coco_kriging_1D.py'

################################################################################
# Functions for spatial kriging (one dimensional), e.g. spatial window-kriging #
# Marie-Christin Juhl, 2024						       #
# mariechristin.juhl@tum.de						       #
################################################################################

#----------------------------------packages-----------------------------------
#from IPython import display
import xarray as xr
import numpy as np
import pandas as pd
import numpy.ma as ma
import gstools as gs
import math
import matplotlib.pyplot as plt
import tqdm
import scipy
import sklearn
import warnings
import haversine as haversine 

warnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning)
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)
















def OrdinaryKriging(l3, grid, fit1, parallel_processparallel_processinging):

    #Ordinary Kriging based on a variogram fit (fit1) 
    
    Z_pred       = []
    Z_pred_error = []

    print('Make distance matrix ... ')
    distances = DISTANCE_MATRIX(l3)       #Distance between all L3-data
    
    C_zz = fit1.variogram(distances)      #LHS
    n    = len(l3)
    K    = np.zeros((n+1,n+1))             
    b    = np.zeros(n+1)                  #RHS Kriging 
    
    K[:n,:n]  = C_zz 
    K[n,n]    = 0
    K[:n,n]   = 1
    K[n,:n]   = 1 
    np.fill_diagonal(K,0.0) #--> force exact values  

    for i in tqdm.tqdm(range(0,len(grid)), desc='Predict grid points..'):
        if grid.land.values[i] !=1:
            Z_ = np.nan
            Z_pred.append(Z_)
            Z_pred_error.append(np.nan)
            
        else:    
        
            u0_    = np.array((grid.longitude.values[i],grid.latitude.values[i])) 
            points = np.array((l3.longitude.values, l3.latitude.values))
            #dist   = haversine_vectorized(points[0,:], points[0,:], u0_[0], u0_[1])
            
            dist = []
            dist=np.zeros((len(points[0])))
            for k in range(0,len(points[0])):
                dist[k] = haversine_(points[0][k], points[1][k],u0_[0],u0_[1])        #haversine distance 

            c_zz = fit1.variogram(dist)
                
            b[:n]     = c_zz  
            b[n]      = 1
            
            #valid_indices = ~np.isnan(b)
            #K_valid = K[valid_indices][:, valid_indices]
            #b_valid = b[valid_indices]
            
            try:
                #w = np.linalg.solve(K_valid,b_valid) #--> not for singular matrices 
                w = np.linalg.solve(K,b)

            except np.linalg.LinAlgError:

                #w = np.dot(scipy.linalg.pinv(K_valid),b_valid) # solve by stimating (Moore-Penrose) pseudo-inverse of a matrix
                w = np.dot(scipy.linalg.pinv(K),b)
            
            Z_ = (np.nansum(w[:n]*l3.resid.values))#*grid['land'].values[i]
            Z_pred.append(Z_)
            Z_pred_error.append((np.dot(w[:n],(c_zz-fit1.nugget))))#*grid['land'].values[i]) ### maybe include Lagrange multiplier ?? 

    return Z_pred, Z_pred_error
